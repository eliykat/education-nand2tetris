// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {

    static Array memory;

    /** Initializes the class. */
    function void init() {
        // Initialise memory variable for direct memory access
        let memory = 0;
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return memory[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let memory[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        // Note: heap is from 2048 - 16383
        var boolean defrag;
        var int block;
        var int prevBlock;

        let defrag = true;  //DISABLED FOR TESTING PURPOSES
        let block = 2048;

        do Sys.poke(block, 16383 - 2048);   // Set initial length
        do Sys.poke(block + 1, null);       // Set next pointer

        // Search through the freeList until a block of sufficient length is found
        // Acceptable block lengths are either:
        // Equal to the required size + 1 (1 being for the 'length' metadata stored before the start of the returned block)
        // OR
        // Equal to or greater than the required size + 3 (1 being for the 'length' metadata, and 2 being to leave behind a block that can still operate in the freeList)
        //      (This is expressed as greater than size + 2 as we do not have a => comparison operator)
        while (~(size + 1 = Sys.peek(block)) & ~(size + 2 > Sys.peek(block)) ) {

            if (Sys.peek(block + 1) = null) {
                if (~defrag) {
                    let defrag = Memory.defrag();
                    let block = 2048;   // Reset loop to try again after defrag
                } else {
                    do Sys.error(6);    // Heap overflow
                }
            }

            let prevBlock = block;
            let block = Sys.peek(block + 1);
        }

        // Found block of required size
        if (size + 1 = Sys.peek(block) ) { 
            // Size matches the block length - remove entire block from list
            do Sys.poke(prevBlock + 1, Sys.peek(block + 1) );
        } else {
            // Size is less than block length, truncate existing block by updating size and moving block pointer
            do Sys.poke(block, Sys.peek(block) - size);
            let block = block + size;
        }

        // Set new block length and return block, starting after length metadata
        do Sys.poke(block, size);
        return block + 1;
    }

    function boolean defrag() {
        var int block;
        var int nextBlock;
        let block = 2048;

        while (Sys.peek(block + 1)) {
            if (block + Sys.peek(block) = Sys.peek(block + 1) ) {
                // Block is physically adjacent to next block
                let nextBlock = Sys.peek(block + 1);

                do Sys.poke(block, Sys.peek(block) + Sys.peek(nextBlock));   // Update size to incorporate both blocks
                do Sys.poke(block + 1, Sys.peek(nextBlock + 1));            // Update pointer to skip nextBlock
            }

            let block = Sys.peek(block + 1);
        }

        return true;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        return;
    }    
}
