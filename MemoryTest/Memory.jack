// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {

    static Array memory;

    /** Initializes the class. */
    function void init() {
        // Initialise memory variable for direct memory access
        let memory = 0;
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return memory[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let memory[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var boolean defrag;
        var int block;
        var int prevBlock;

        let defrag = true;  //DISABLED FOR TESTING PURPOSES
        let block = 2048;

        // Search through the freeList until a block of sufficient length is found
        // Acceptable block lengths are either:
        // Equal to the required size + 1 (1 being for the 'length' metadata stored before the start of the returned block)
        // OR
        // Equal to or greater than the required size + 3 (1 being for the 'length' metadata, and 2 being to leave behind a block that can still operate in the freeList)
        //      (This is expressed as greater than size + 2 as we do not have a => comparison operator)
        while (~(size + 1 = memory[block]) & ~(size + 2 > memory[block])) {

            if (memory[block + 1] = null) {
                if (~defrag) {
                    let defrag = Memory.defrag();
                    let block = 2048;   // Reset loop to try again after defrag
                } else {
                    do Sys.error(6);    // Heap overflow
                }
            }

            let prevBlock = block;
            let block = memory[block + 1];
        }

        // Found block of required size
        if (size + 1 = memory[block]) { 
            // Size matches the block length - remove entire block from list
            let memory[prevBlock + 1] = memory[block + 1];

        } else {
            // Size is less than block length, truncate existing block by updating size and moving block pointer
            let memory[block] = memory[block - size];
            let block = block + size;
        }

        // Set new block length and return block, starting after length metadata
        let memory[block] = size;
        return block + 1;
    }

    function boolean defrag() {
        var int block;
        let block = 2048;

        while (memory[block + 1]) {
            if (block + memory[block] = memory[block + 1]) {
                // Block is physically adjacent to next block
                let memory[block] = memory[block] + memory[memory[block]];
                let memory[block + 1] = memory[memory[block + 1]];
            }

            let block = memory[block + 1];
        }

        return true;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        return;
    }    
}
